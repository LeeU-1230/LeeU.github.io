{"posts":[{"title":"Google - Cloud Firestore 數據的寫入讀取","text":"Cloud Firestore 是 Google 提供的即時資料庫，可即時監聽資料庫的變化，並同步使用各個應用。 數據結構在 Cloud Firestore 中構建數據時，分為集合( collection ) 與文件 ( doc ) ，集合包含著文件，文件裡還可包含著子集合，而數據資料只能存在文件上。 寫入資料set (設定) 可設定在指定集合裡添加文件並寫入資料。( 可指定 doc 名稱 ) 若沒有指定文件 doc 的名稱，會自動產生一個亂數代碼作為文件名稱。 12345678910let db = firebase.firestore();let ref = db.collection(&quot;users&quot;).doc(&quot;frank&quot;);ref.set({ name: &quot;Frank&quot;, favorites: { food: &quot;Pizza&quot;, color: &quot;Blue&quot;, subject: &quot;recess&quot; }, age: 12}).then(() =&gt; { console.log('set data successful');}); merge 方法 : 進行合併整理，而不會覆蓋資料。 12345ref.set({ sex : 'Male'},{merge:true}).then(() =&gt; { console.log('set data successful');}); add (添加)add 可以自動添加文件，文件名稱為系統自動產生的亂碼。 12345678db.collection(&quot;users&quot;).add({ first: &quot;Alan&quot;, middle: &quot;Mathison&quot;, last: &quot;Turing&quot;, born: 1912}).then(() =&gt; { console.log('set data successful');}); update (更新) 對 doc 內某個屬性進行更新，避免覆寫整個文件內容。 更新下階子屬性使用 . 來做更新。 123456ref.update({ &quot;age&quot;: 13, &quot;favorites.color&quot;: &quot;Red&quot;}).then(() =&gt; { console.log('set data successful');}); delete (刪除)用於刪除集合或是文件，但如果集合裡有文件，則無法刪除集合。 123db.collection(&quot;users&quot;).doc('OS0t1rl9S9tpFtlve8H1').delete().then(() =&gt; { console.log('delete data successful');}); 若想刪除文件內的某個屬性，則需要透過update的方式來實現。 12345ref.update({ sex: firebase.firestore.FieldValue.delete()}).then(() =&gt; { console.log('set data successful');}); ![](https://drive.google.com/uc?export=view&amp;id=1YvOO7BlXUAngQkpR2cTxLywZtQ0SPlaQ) 讀取資料有讀取 ( get ) 和即時監聽 ( onSnapshot ) 兩種方法，可以搭配篩選 ( where ) 和排序 ( orderBy ) 來進一步的篩選。 以下為範例資料庫數據: get (取得資料) 取得集合裡，所有文件的資料，並使用 forEach 個別取出文件內容。 12345678 let db = firebase.firestore();let ref = db.collection(&quot;users&quot;);ref.get().then(querySnapshot =&gt; { querySnapshot.forEach(doc =&gt; { console.log(doc.id, doc.data()); });}); 指定文件的名稱，則直接取得文件內容。 12345let ref = db.collection(&quot;users&quot;).doc('ming');ref.get().then(doc =&gt; { console.log(doc.id, doc.data());}); onSnapshot (即時監聽)可以即時監聽資料庫的變化。 12345678let db = firebase.firestore();let ref = db.collection(&quot;users&quot;);ref.onSnapshot(querySnapshot =&gt; { querySnapshot.forEach(doc =&gt; { console.log(doc.id, doc.data()); });}); where (篩選)進行資料篩選，包含三個參數，第一個是屬性名稱，第二個是邏輯運算子，第三個是屬性值。邏輯運算子包含: &lt;、&lt;=、==、&gt;、&gt;=、!=、in ( 邏輯OR )、not-in ( 邏輯AND ) 。 12345678let db = firebase.firestore();let ref = db.collection(&quot;users&quot;);ref.where('sex','==','Male').get().then(querySnapshot =&gt; { querySnapshot.forEach(doc =&gt; { console.log(doc.id, doc.data()); });}); orderBy (排序)會和 limit (用於檢索文檔數量)搭配，作為排序後篩選特定數量的資料。orderBy 有兩個參數，第一個是屬性名稱，第二個是遞增 ( asc ) 或遞減 ( desc ) 。 12345ref.orderBy('age','desc').limit(3).get().then(querySnapshot =&gt; { querySnapshot.forEach(doc =&gt; { console.log(doc.id, doc.data()); });});","link":"/2020/12/17/GOOGLE/%E6%95%B8%E6%93%9A%E7%9A%84%E5%AF%AB%E5%85%A5%E8%AE%80%E5%8F%96/"},{"title":"使用 Google Drive 建立圖床","text":"使用 GoogleDrive 雲端硬碟當做部落格網站的圖床。 步驟1.圖片需開啟共用連結的權限。 2.點圖呈現預覽畫面後，在右上方的更多動作中選擇在新視窗開啟。 3.複製網址列中的圖片id字串https://drive.google.com/file/d/id字串/view 4.以https://drive.google.com/uc?export=view&amp;id=加上id字串就是連結顯示的網址。例: https://drive.google.com/uc?export=view&amp;id=id字串","link":"/2020/11/25/GOOGLE/google%20Drive%E5%BB%BA%E7%AB%8B%E5%9C%96%E5%BA%8A/"},{"title":"CSS語法 - Animation(動畫)","text":"紀錄 CSS Animation的使用方法。 @keyframes在@keyframes 規則內指定CSS樣式。0% 表示起始，100% 表示結束。 以下執行後就會花5秒的時間，往右移動到 200px 的位置，再移動回 0px 的位置停止。 123456789101112131415161718192021.box1 { position: absolute; left: 0; width: 50px; height: 50px; background-color: red; animation-name: mov; animation-duration: 5s;}@keyframes mov{ 0% { left: 0px; } 50%{ left: 200px; } 100%{ left: 0px; }} animation-name動畫名稱。(必要) animation-duration動畫持續時間，單位為 秒 ( s ) 或毫秒 ( ms )。(必要) animation-iteration-count動畫播放次數，預設值為 1 次，infinite 值為無窮重複。 animation-delay動畫延遲播放時間，單位為 秒 ( s ) 或毫秒 ( ms )。若將延遲播放時間設定為「負值」，則是快轉(例如 -2s，會直接從第二秒的位置開始播放) animation-timing-function加速度函式。值有: ease: 慢-快-慢(預設值)。還有 ease-in、ease-out、ease-in-out linear: 線性。 animation-direction播放方向。值有: normal: 正常播放(預設值)。 reverse: 反轉。 alternate: 正-反輪播。 alternate-reverse: 反-正輪播。 animation-fill-mode播放結束後的模式。值有: none: 返回原始狀態(預設值)。 forwards: 保持在結束的狀態。 backwards: 保持在開始的狀態。 both animation-play-state播放或暫停動畫。值有: running: 運行(預設值)。 paused: 暫停。 Animation Events可以使用 JavaScript 來接收動畫所產生的事件。 animationstart: 當動畫開始。 animationend: 當動畫結束。 animationiteration: 當動畫重複播放。 CSSKeyframesRule可以使用 JavaScript 來修改動畫內容。 document.styleSheets : 包含了頁面中所有的外部樣式表的陣列。cssRules : 存在於 styleSheets 中的屬性，可用來新增、刪除或編輯己存在的樣式規則。而取得 cssRules 內的CSSKeyframesRule，就能夠修改動畫內容。 支援的方法: findRule(): 尋找。 appendRule(): 添加。 deleteRule(): 刪除。 以下為點擊按鈕後會更換動畫的內容。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn&quot;&gt;更換&lt;/button&gt;&lt;style&gt; .box1 { position: absolute; left: 0; top: 50px; width: 50px; height: 50px; background-color: red; animation-name: mov; animation-duration: 5s; animation-iteration-count: 5; } @keyframes mov { 0% { left: 0px; } 50% { left: 200px; } 100% { left: 0px; } }&lt;/style&gt;&lt;script&gt; var btn = document.getElementById('btn'); var keyframes = document.styleSheets[0].cssRules[1]; console.log(keyframes); btn.addEventListener('click', function () { console.log(keyframes.findRule('50%')); keyframes.appendRule('50% {left:300px; background:blue;}'); // 向右移300px，背景色轉為藍色 });&lt;/script&gt; 參考資料 :oxxostudio","link":"/2020/12/18/CSS/Animation-%E5%8B%95%E7%95%AB/"},{"title":"使用 CSS 語法做網頁漸層","text":"漸層漸層效果需要設定至少兩種顏色在開頭和結尾，可以設定多種顏色，瀏覽器會自動計算中間漸變的顏色。 使用對象: background、list-style-image 漸層類型: linear-gradient、radial-gradient、conic-gradient linear-gradient(方向, 顏色1 位置1, 顏色2 位置2);線性漸層，依指定角度來直線產生對應的顏色。 方向: 預設從上往下漸變(to bottom | 180deg)，可以使用角度(0~180deg)或方向屬性(to top | bottom | left | right)。 位置: 0%~100%，沒有指定參數時，則會自動等比例分配。設定每個顏色的位置不要重疊，就可以出現漸層。12345div { width: 300px; height: 300px; background-image: linear-gradient(blue, green);} 12345div { width: 300px; height: 300px; background-image: linear-gradient(blue 50%, green 50%);} repeating-linear-gradient線性重複漸層，需要指定需要重複的顏色位置。 12345div { width: 300px; height: 300px; background-image: repeating-linear-gradient(blue 0%, blue 5%, pink 5%, pink 10%);} radial-gradient(方式 尺寸 at 中心位置, 顏色1 位置1, 顏色2 位置2)放射漸層，從單點出發，以圓形或橢圓的方式向外放射。 方式: circle (圓形) | ellipse (橢圓,預設) 尺寸: farthest-corner (最遠角,預設) | closest-side (最近邊) | farthest-side (最遠邊) | closest-corner (最近角) | x軸 y軸(橢圓,例: 80% 20%) 中心位置: center (預設) 12345div { width: 300px; height: 300px; background-image: radial-gradient(blue, pink)} 12345div { width: 300px; height: 300px; background-image: radial-gradient(blue 20%, pink 55%, orange 90%)} repeating-linear-gradient放射重複漸層 conic-gradient(顏色1 位置1, 顏色2 位置2);錐形漸層。 12345div { width: 300px; height: 300px; background-image: conic-gradient(blue, pink)} 12345div { width: 300px; height: 300px; background-image: conic-gradient(blue 0, blue 180deg, pink 180deg, pink 360deg)} 參考資料 :oxxostudio","link":"/2021/01/01/CSS/CSS-%E6%BC%B8%E5%B1%A4/"},{"title":"使用 CSS 排版 - Flex 屬性","text":"FlexboxCSS 常見的排版方式之一，Flex 中分為外部容器與內部元件，外部容器設定 display: flex。 1234567891011121314151617181920212223&lt;style&gt; .box { display: flex; } .inbox { width: 100px; height: 100px; } .inbox-big { width: 100px; height: 100px; }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;inbox&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;inbox-big&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;inbox&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;inbox-big&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;inbox&quot;&gt;5&lt;/div&gt;&lt;/div&gt; flex-direction設置內部元件排序方向。 左→右(預設):flex-direction : row 右→左:flex-direction : row-reverse 上→下:flex-direction : column1234.box { display: flex; flex-direction: column;} 下→上:flex-direction : column-reverse flex-wrap設置元件超出容器時，是否換行。 換行:flex-wrap : wrap1234567891011121314.box { display: flex; flex-wrap: wrap;}.inbox { width: 300px; height: 100px;}.inbox-big { width: 300px; height: 100px;} 不換行:flex-wrap : nowrap 換行反轉:flex-wrap : wrap-reverse justify-content設置內部元件水平對齊方式。 預設值，對齊到開頭justify-content : flex-start 對齊到結尾justify-content : flex-end 水平置中justify-content : center1234.box { display: flex; justify-content:center;} 平均分配內容元素，左右的內部元件貼齊外部容器justify-content : space-between1234.box { display: flex; justify-content:space-between;} 平均分配內部元件、間距justify-content : space-around1234.box { display: flex; justify-content:space-around;} align-items設置內部元件垂直對齊方式。 對齊最上方align-items : flex-start 對齊最下方align-items : flex-end 垂直置中align-items : center1234.box { display: flex; align-items: center;} 內部元件全部撐開至 Flexbox 的高度(預設)align-items:stretch; 以所有內部元件內容的基線作為對齊標準align-items:baseline;123456789101112131415.box { display: flex; align-items: baseline;}.inbox { width: 100px; height: 100px;}.inbox-big { width: 100px; height: 300px; font-size: 50px;} align-content適用於多行元素的垂直對齊方式。 flex-start flex-end center space-between space-around stretch (預設) flex-grow伸展(空間足夠時，依數字做相應比例分配)，使用在內部元件上預設值為 0，不伸展 123456789101112131415.box { display: flex;}.inbox { width: 100px; height: 100px; flex-grow: 2;}.inbox-big { width: 100px; height: 100px; font-size: 50px;} flex-shrink壓縮(空間不足時，依數字做相應比例分配)，使用在內部元件上預設值為 1，會彈性壓縮 align-self調整個別內部元件的垂直對齊設定，使用在內部元件上設定值與 align-items 相同 12345678910111213141516.box { display: flex; height: 300px;}.inbox { width: 100px; height: 100px;}.inbox-big { width: 100px; height: 100px; font-size: 50px; align-self: flex-end;} order重新定義元件的排列順序(依設置數字大小)，使用在內部元件上 123456789101112131415161718192021.box { display: flex; height: 300px; border: 2px blueviolet solid; text-align: center; font-size: large; font-weight: bold;}.inbox { width: 100px; height: 100px; order: 0;}.inbox-big { width: 100px; height: 100px; font-size: 50px; order: 1;}","link":"/2020/12/04/CSS/Flex%E7%B4%80%E9%8C%84/"},{"title":"CSS語法 - Transform(變形)","text":"transform屬性能使用translate (移動)、rotate (旋轉)、scale (縮放)、skew (傾斜)。 translate（） 移動從當前位置移動元素。數值: 包含單位的數值(例: 50px)。 123div { transform: translate(50px, 100px);} rotation（） 旋轉根據角度旋轉元素。數值: 角度(例: 90deg)。 123div { transform: rotate(90deg);} scale（） 縮放依據數值調整元素的寬高。數值: 數字(例: 0.5, 2)。 123div { transform: scale(0.5, 2);} scaleX（） 縮放元素的寬度scaleY（） 縮放元素的高度 skew（） 傾斜依據角度傾斜元素。數值: 角度(例: 20deg, 10deg) 123div { transform: skew(20deg, 10deg);} skewX（） 依元素的X軸傾斜skewY（） 依元素的Y軸傾斜 3D變形 rotateX() 依角度圍繞元素的X軸來旋轉123div { transform: rotateX(150deg);} rotateY() 依角度圍繞元素的Y軸來旋轉123div { transform: rotateY(150deg);} rotateZ() 依角度圍繞元素的Z軸來旋轉123div { transform: rotateZ(150deg);}","link":"/2021/01/01/CSS/Transform-2D%E8%AE%8A%E5%BD%A2/"},{"title":"CSS語法 - 偽class","text":"偽class是用來執行在特定動作時改變文字樣式。 用來設定連結的樣式 :link 未訪問過的連結。 :visited 已訪問過的連結。 對於使用者的操作做出樣式改變。 :hover 當鼠標滑入。 :active 使用滑鼠點擊。 :focus 當元素有焦點。 :target使用於連結與連結的錨點相符的 id 其目標元素。例如：點擊 Open example 顯示 id=”example” 的元素，點擊 Close 則將其隱藏。 範例 : :target 12345678910111213141516171819&lt;div&gt; &lt;a href=&quot;#example&quot;&gt;Open example&lt;/a&gt;&lt;/div&gt;&lt;div id=&quot;example&quot; class=&quot;box&quot;&gt; &lt;div&gt; 123456789 &lt;/div&gt; &lt;a href=&quot;#&quot;&gt;Close&lt;/a&gt;&lt;/div&gt;&lt;style&gt; .box { display: none; } .box:target { display: block; }&lt;/style&gt; 套用在 input 上使用 :checked 選取時( radio、checkbox 使用 )。例如：切換顯示與否。 範例 : :checked 12345678910111213141516171819202122232425262728293031&lt;div&gt; &lt;input type=&quot;checkbox&quot; name=&quot;my-box&quot; id=&quot;op&quot;&gt; &lt;p&gt;123&lt;/p&gt; &lt;p class=&quot;text&quot;&gt;456&lt;/p&gt; &lt;p class=&quot;text&quot;&gt;789&lt;/p&gt; &lt;label for=&quot;op&quot; id=&quot;btn&quot;&gt;點點我!&lt;/label&gt;&lt;/div&gt;&lt;style&gt; #op { display: none; } .text { display: none; } #btn { display: inline-block; background-color: #ff7; border: 1px solid; } #op:checked~ .text { display: block; } #op:checked~ #btn{ background-color: #ccc; }&lt;/style&gt; :disabled 禁用狀態。 :enabled 啟用狀態。 :placeholder 提示字樣式。:placeholder123456789101112131415&lt;input type=&quot;text&quot; placeholder=&quot;輸入&quot;&gt;&lt;style&gt; input::placeholder { color: rgb(96, 123, 244); } input:focus { background-color: lightblue; } input:focus::placeholder { color: orange; }&lt;/style&gt; 排除選擇相符的元素 :not(選擇器參數) 排除選擇相符的元素。例如：選取 input 中所有不是 type=”checkbox” 的元素。1input:not[type=&quot;checkbox&quot;] 參考資料 :MDN重新認識 CSS - Pseudo-class (偽類) (1)","link":"/2021/01/10/CSS/%E5%81%BDclass/"},{"title":"使用 CSS 語法限制文本內容","text":"目標 : 當文字超過限制時會自動顯示”…”的省略號。使用「text-overflow: ellipsis;」隱藏內容。 HTML : 12345&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;p&gt;臣亮言：先帝創業未半，而中道崩殂。今天下三分，益州疲弊，此誠危急存亡之秋也。然侍衛之臣，不懈於內；忠志之士，忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。誠宜開張聖聽，以光先帝遺德，恢宏志士之氣；不宜妄自菲薄，引喻失義，以塞忠諫之路也。 &lt;/p&gt; &lt;/div&gt; CSS : 123456.box { width: 200px; height: 50px; padding: 10px; border: 2px blueviolet solid;} 在文字的區塊使用 text-overflow: ellipsis;需一併設定 white-space: nowrap; 及 text-overflow: ellipsis; 才會有效果。 CSS : 123456789101112.box { width: 200px; height: 50px; padding: 10px; border: 2px blueviolet solid;}p { overflow: hidden; white-space: nowrap; text-overflow: ellipsis;} text-overflow: clip;裁剪文字內容。 word-wrap: break-word;依據空白來換行。 word-break: keep-all;依據空白來換行。 word-break: break-all;到邊界立即斷行。 writing-mode: horizontal-tb;水平顯示文本。 writing-mode: vertical-rl;由右到左垂直顯示文本。 writing-mode: vertical-lr;由左到右垂直顯示文本。","link":"/2020/12/07/CSS/%E4%BD%BF%E7%94%A8CSS%E9%99%90%E5%88%B6%E5%85%A7%E5%AE%B9/"},{"title":"使用 CSS 語法改變滑鼠游標的形狀","text":"透過 cursor 屬性改變滑鼠形狀屬性值: default (預設) | none | pointer | wait | crosshair | text | vertical-text | move | … 範例 : cursor 參考連結 : MDN","link":"/2021/02/26/CSS/%E4%BD%BF%E6%BB%91%E9%BC%A0%E6%8C%87%E6%A8%99%E6%94%B9%E8%AE%8A%E5%BD%A2%E7%8B%80/"},{"title":"使用 CSS 語法製作計數列表 &#x2F; 有序列表","text":"counter 計數器 範例 : counter 123456&lt;div&gt; &lt;p&gt;ABC&lt;/p&gt; &lt;p&gt;DEF&lt;/p&gt; &lt;p&gt;GHI&lt;/p&gt; &lt;p&gt;JKL&lt;/p&gt;&lt;/div&gt; 12345678div { counter-reset: num; /* 創建計數器 */}p::before { counter-increment: num; /* 累加值 */ content: &quot;選項 &quot; counter(num) &quot;. &quot;;} 參考資料 :MDN","link":"/2021/01/09/CSS/%E8%A3%BD%E4%BD%9C%E8%A8%88%E6%95%B8%E5%99%A8/"},{"title":"CSS語法 - max、min、clamp 數學函式","text":"透過CSS語法可進行動態的數學函數運算。 max()定義了運算最大值，作用在於限制最小值。 例如: div 的寬度為50%，最小寬度為300px 123div { width: max(50%, 300px); } 等同於 1234div { width: 50%; min-width: 300px;} min()定義了數學運算的最小值，作用在於限制最大值。 例如: div 的寬度為50%，最大寬度為300px 123div { width: min(50%, 300px); } 等同於 1234div { width: 50%; max-width: 300px;} clamp()clamp(最小值, 中間值, 最大值)返回一個區間範圍的值。 例如: div 的最小寬度為300px，最大寬度為500px，在範圍內則寬度為50% 123div { width: clamp(300px, 50%, 500px); } 等同於 12345div { width: 50%; min-width: 300px; max-width: 500px;} 參考資料 :oxxostudio","link":"/2020/12/18/CSS/%E6%95%B8%E5%AD%B8%E5%87%BD%E5%BC%8F/"},{"title":"CSS語法 - 偽元素","text":"偽元素使用偽元素能簡化頁面上 HTML 標籤，讓 HTML 的維護更加輕鬆。 在 W3C 的定義裡總共有五個偽元素（其他仍在測試階段），分別是 ::before、::after、::first-line、::first-letter 和 ::selection。 ::before 插入在一個元素之前，以 display:inline-block 的屬性存在。 :: after 插入在一個元素之後，以 display:inline-block 的屬性存在。 ::first-line 將文本的第一行添加樣式，不能作用於 display:inline 的元素。 ::first-letter 將文本的第一個字母添加樣式。 ::selection 選取段落文字的樣式屬性。 content 屬性content 屬性與 ::before 和 ::after 一起使用在文檔中生成內容，使用 ::before 和 ::after 一定要有 content 否則不會發生作用。 content 的值: normal | none (預設) string 會在之前或之後加入字串，可以針對字串作樣式的變換。123456789div::before { content: '&lt;'; color: blue;}div::after { content: '&gt;'; color: red;} url 插入圖片、聲音或影像。 attr(屬性) 插入指定屬性的值。1234a::before { content: attr(href); color: blue;} open-quote | close-quote 給予開始、結束的引號。12345678910111213p:before { content: open-quote;}p:after { content: close-quote;}p:before,p:after { font-size: 3em; color: gray;} no-open-quote | no-close-quote 取消開始、結束的引號。 使用空白可以相加 content 的內容。1234a::before { content: ''attr(href)' &lt;'; color: blue;} 搭配 quotes 屬性在元素上設定自定義的括號。quotes 支援巢狀的結構，前後括號使用空白區隔，兩組為一個單位，前後可以不同符號。 1234567891011121314151617p { quotes: '*' '*';}p:before { content: open-quote;}p:after { content: close-quote;}p:before,p:after { font-size: 3em; color: gray;} 參考資料 :MDN","link":"/2020/12/20/CSS/%E5%81%BD%E5%85%83%E7%B4%A0/"},{"title":"使用 CSS 變數管理樣式","text":"使用 CSS 變數，讓樣式的管理更為方便、視覺上更有統整性。 基礎寫法基本上定義變數，會將變數寫在 :root 裡，讓網頁中所有元素的 CSS，都能使用這個變數。 宣告(以兩個破折號 – 作為開頭)： –名稱: 值; 使用(以 var 作為開頭)： 屬性：var(–名稱[, 預設值]); 預設值(非必要)可以在無法讀取變數名稱時自動套用。 1234567891011:root { /* 宣告變數 */ --bg_color: lightblue;}.box1 { /* 使用變數 */ background-color: var(--bg_color);}.box2 { /* box2讀取不到 color 變數，所以使用 green */ background-color: var(--color, green);} 全域變數將變數寫在 :root 裡，或寫在 html 與 body 裡，讓網頁的元素也都可以使用這個變數。 區域變數 寫在不同網頁元素內 若變數名與父元素相同，而在父元素重新賦值，則會套用父元素的變數數值12345678910111213:root { --bg_color: lightblue; --color: yellow;}.box1 { background-color: var(--bg_color); --color: orange; /* 在 box1 裡面覆寫 --color 的值*/}h1 { /* box1 裡面的 h1 的顏色會是 orange */ color: var(--color);} 搭配 calc 數學運算1234567:root { --w: 20%;}div { width: calc(50% + var(--w)); /* 寬度為 50% + 20% */} JavaScript 操作 .style.setProperty12const root = document.documentElement;root.style.setProperty('--color', 'red'); .style.cssText12const root = document.documentElement;root.style.cssText = '--color: red'; 參考資料 :oxxostudio","link":"/2020/12/18/CSS/%E8%AE%8A%E6%95%B8/"},{"title":"使用 CSS 語法讓搜索欄具備取消按鈕吧!","text":"使搜索欄 input[type=”search”] 具有取消按鈕。 範例 : search-cancel-button 參考連結 : MDN 1234567input[type=search] { -webkit-appearance: search_btn;}input[type=&quot;search&quot;]::-webkit-search-cancel-button{ -webkit-appearance: search_btn-cancel-button;}","link":"/2021/02/26/CSS/%E8%AE%93%E6%90%9C%E7%B4%A2%E6%AC%84%E5%85%B7%E5%82%99%E5%8F%96%E6%B6%88%E6%8C%89%E9%88%95%E5%90%A7/"},{"title":"HTML - &lt;picture&gt; 標籤","text":"&lt;picture&gt; 標籤用途 多用在響應式網頁設計 可根據不同螢幕尺寸載入圖片 可根據瀏覽器支援的格式來載入不同格式的圖片 &lt;picture&gt; 語法範例&lt;picture&gt; 容器裡面使用多個 &lt;source&gt; 和一個 &lt;img&gt; 來設定。先從 &lt;source&gt; 去找有沒有匹配的圖片，沒有的話則使用 &lt;img&gt; 設定的圖片。 12345&lt;picture&gt; &lt;source srcset=&quot;/photo/dog-600.jpg&quot; media=&quot;(min-width: 600px)&quot;&gt; &lt;img src=&quot;/photo/dog.jpg&quot;&gt;&lt;/picture&gt; &lt;source&gt; 標籤屬性 media : 用來設定 media query 條件。 srcset : 設定一張或多張(逗點分隔)不同尺寸的圖片。尺寸可以使用圖片像素寬度(單位 w)或螢幕解析度(單位 x)。 type : 指定圖片的檔案格式，當瀏覽器不支援此格式時會忽略這張圖片。 1234567&lt;picture&gt; &lt;source srcset=&quot;/photo/dog-600.jpg 600w, /photo/dog-600-2.jpg 2x&quot; srcset=&quot;/photo/dog-300.jpg 300w, /photo/dog-600-1.5.jpg 1.5x&quot; media=&quot;(min-width: 600px)&quot; type=&quot;image/jpeg&quot;&gt; &lt;img src=&quot;/photo/dog.png&quot;&gt;&lt;/picture&gt;","link":"/2021/01/06/HTML/HTML-picture-%E6%A8%99%E7%B1%A4/"},{"title":"什麼是HTML?","text":"HTMLHTML（HyperText Markup Language，超文本標記語言）是打造網頁的基石。它表述並定義網頁的內容，包含了一系列的元素（elements），而元素包含了標籤（tags）與內容（content），我們用標籤來控制內容的呈現樣貌，例如字體大小、斜體粗體、在文字或圖片設置超連結等。伴隨 HTML 而來的技術還有描述網頁外觀（CSS）及功能性的程式語言（JavaScript）。 HTML的元素組成基本的架構： 起始標籤 （The opening tag）：**先打大於、小於的符號「&lt; &gt;」，裡面再放入元素名稱，如上面的例子「&lt;p&gt;」。起始標籤代表這個元素從這裡開始。 結束標籤 （The closing tag）： 與起始標籤一樣，只是在元素名稱前面多了個前置斜線「/」。 內容（The content）： 這個元素的內容，以上面的例子來說，內容就是這句文字。 元素（The element）： 由起始標籤、結束標籤、內容所組成。 元素還可以有「屬性（Attribute）」： 屬性能提供更多的資訊（當然，這個資訊是幫助我們更有效及方便編輯，不會呈現在網頁上），屬性包含了屬性名稱與值，你可以利用屬性設定這個元素的色彩、對齊方式、圖表的格線等等。 巢狀元素元素裡面可以在放進元素，我們稱之為「巢狀元素（nesting element）」。例如這個句子：「My cat is very grumpy.」，若想強調「very」，就可以把「very」顯示為粗體的元素。 1&lt;p&gt;My cat is &lt;strong&gt;very&lt;/strong&gt; grumpy.&lt;/p&gt; 空元素有些元素沒有內容，稱為「空元素（empty elements）」。 以圖片元素 為例： 1&lt;img src=&quot;images/firefox-icon.png&quot; alt=&quot;My test image&quot;&gt; HTML文件架構一個完整的 HTML 頁面它所包含的要素： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;My test page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;images/firefox-icon.png&quot; alt=&quot;My test image&quot;&gt; &lt;/body&gt;&lt;/html&gt; &lt;!DOCTYPE html&gt; — 文件類型（doctype）,表示這是一份標準的HTML5 文件。 &lt;html&gt; 元素，又被視為根元素（root element），包含了所有顯示在這個頁面上的內容。 &lt;head&gt; 元素，裡面放的是你想涵括的重要資訊，但不會顯示於網頁瀏覽者眼前的。例如，顯示於搜尋結果的關鍵字、頁面說明、CSS、字元實體集…等。 &lt;body&gt; 元素，包含了所有會顯示於網頁瀏覽者眼前的內容。 無論是文字、圖片、影面、互動遊戲…等。 &lt;meta charset=&quot;utf-8&quot;&gt; — 這個元素指定了你的文件使用 utf-8 這種字元編碼， 建議大家都要使用這個元素，它會幫助你免去許多文字無法正確呈現的煩惱。 &lt;title&gt; — 呈現於網頁瀏覽者眼前的網頁標題。 加入圖片1&lt;img src=&quot;images/firefox-icon.png&quot; alt=&quot;My test image&quot;&gt; 透過圖片來源（src ，source）這個屬性，提供了連到圖片檔案的路徑。 加上alt (alternative) 這個屬性。在網頁瀏覽者無法正確看到圖片時，你希望對他們呈現什麼樣的說明文字。 文章標題(heading)HTML 最多可以有六層的 heading， &lt;h1&gt; ~ &lt;h6&gt;。 1&lt;h1&gt;My title&lt;/h1&gt; My title 段落 (paragraph)呈現一般文字。 1&lt;p&gt;This is a single paragraph&lt;/p&gt; This is a single paragraph 清單(list)清單包含無順序性與有順序性的： 無順序性清單（Unordered lists）12345&lt;ul&gt; &lt;li&gt;國文&lt;/li&gt; &lt;li&gt;英文&lt;/li&gt; &lt;li&gt;數學&lt;/li&gt;&lt;/ul&gt; 國文 英文 數學 有順序性清單（Ordered lists）12345&lt;ol&gt;&lt;li&gt;第一天&lt;/li&gt;&lt;li&gt;第二天&lt;/li&gt;&lt;li&gt;第三天&lt;/li&gt;&lt;/ol&gt; 第一天 第二天 第三天 連結 (link)讓文字變成連結 例如「GOOGLE」，包在&lt;a&gt;元素裡：1&lt;a&gt;GOOGLE&lt;/a&gt; 在&lt;a&gt;中加上 href，屬性屬性值就是你要連結網址：1&lt;a href=&quot;https://www.google.com.tw/&quot;&gt;GOOGLE&lt;/a&gt; GOOGLE 參考資料 MDN","link":"/2023/03/14/HTML/HTML%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/"},{"title":"HTML - 表單標籤","text":"&lt;form&gt;建立一個 HTML 表單，&lt;form&gt; 做為表單的容器。 屬性: action 指定一個位址 (URL)，要將表格的內容傳送過去。 method 指定資料傳輸時用的 HTTP 協議。( GET / POST ) GET : 用在資料量較小或非敏感的資料，因為資料會被放在網址中直接傳出。 POST : 用在表單資料量較大、有夾帶檔案上傳或隱私性考量的資料。 target 指定瀏覽器要在何處顯示伺服器回應的結果。 _self : 顯示在表單所在的當前視窗。 _blank : 顯示在新視窗。 _parent : 顯示在上一層的視窗。 _top : 顯示在最頂層的視窗。 autocomplete 是否啟用瀏覽器自動完成機制。( on(預設) / off ) &lt;input&gt;建立不同用途的表單控制元件。 屬性: name 欄位名稱。 value 初始值。1&lt;input value=&quot;初始值&quot;&gt; disabled 設為禁用狀態。1&lt;input value=&quot;此格禁用&quot; disabled&gt; readonly 設為唯獨，不可更改狀態。1&lt;input value=&quot;此格不可更改&quot; readonly&gt; autocomplete 是否啟用瀏覽器自動完成功能( on / off )。 autofocus 頁面載入後，自動聚焦。 required 設為必填欄位。 pattern 表單欄位驗證。搭配正規表示法。&lt;input pattern=”正規表達式”&gt; text, date, search, url, tel, email 和 password 等輸入欄位可以使用。 type 建立不同的表單元件。 type 屬性建立不同的表單元件。 type=’text’ 文字輸入。 maxlength 屬性: 最多輸入字數。 minlength 屬性: 最少輸入字數。 size 屬性: 欄位顯示寬度。 placeholder 屬性: 提示訊息。1&lt;input placeholder=&quot;請輸入使用者帳號&quot;&gt; type=’password 和 text 的差別是，輸入的內容不會被明碼顯示在畫面中。 type=’checkbox’ 核取方塊，勾選某個選項是否成立，可多選。12&lt;input type=&quot;checkbox&quot; name=&quot;fast_food&quot; value=&quot;McDonald's&quot;&gt; 喜歡麥當勞&lt;input type=&quot;checkbox&quot; name=&quot;fast_food&quot; value=&quot;KFC&quot;&gt; 喜歡肯德基 喜歡麥當勞 喜歡肯德基 type=’radio’ 選項按鈕，多選一。同一組的選項，需要一樣的name。 checked 屬性: 可以將該 checkbox / radio 的初始狀態設定為已選取。 1234選擇你最喜歡的顏色：&lt;input type=&quot;radio&quot; name=&quot;color&quot; value=&quot;red&quot;&gt; red&lt;input type=&quot;radio&quot; name=&quot;color&quot; value=&quot;green&quot;&gt; green&lt;input type=&quot;radio&quot; name=&quot;color&quot; value=&quot;blue&quot;&gt; blue 選擇你最喜歡的顏色： red green blue type=’submit’ 表單送出按鈕。1&lt;input type=&quot;submit&quot; value=&quot;Send&quot;&gt; type=’reset’ 重設表單內容。1&lt;input type=&quot;reset&quot; value=&quot;Reset&quot;&gt; type=’hidden’ 隱藏資料欄位。 type=’image’ 圖片送出按鈕，使用圖片表示的送出按鈕。 src 屬性: 圖片位址。 alt 屬性: 當圖片下載失敗時的替代文字。 width 屬性: 圖片寬度。 height 屬性: 圖片高度。 type=’file’ 選擇上傳的檔案。 accept 屬性: 限制允許上傳的檔案類型。可用逗點分隔多種允許類型。值: . 檔案類型: .jpg、.pdf、.png…等。 指定檔案類型: image/png、image/jpg等。 audio/*: 任意聲音檔。 video/*: 任意影片檔。 image/* : 任意圖片檔。 multiple 屬性: 可同時選多個檔案上傳。 capture 屬性 : 可用來開啟使用手機的照相鏡頭。值: user : 開啟前鏡頭。 environment : 開啟後鏡頭。 type=’button’ 表單按鈕。 type=’search’ 搜尋框。 type=’tel’ 電話號碼輸入欄位。 type=’url’ 網址輸入欄位。 type=’email’ 電子郵件輸入欄位。 type=’number’ 數字輸入欄位。 max 屬性: 可輸入的最大值。 min 屬性: 可輸入的最小值。 step 屬性: 控制數字一次跳動的幅度。 type=’range’ 使用滑動的方式在一個數字區間內選擇出一個值。1&lt;input type=&quot;range&quot; min=&quot;1&quot; max=&quot;10&quot;&gt; type=’date’ 日期輸入欄位。 max 屬性: 可輸入的最晚日期。 min 屬性: 可輸入的最早日期。 step 屬性: 控制日期一次跳動的幅度。12345&lt;input type=&quot;date&quot; value=&quot;2020-12-25&quot; min=&quot;2020-12-01&quot; max=&quot;2022-12-31&quot; step=&quot;5&quot;&gt; type=’time’ 時間輸入欄位。(同樣有max、min、step) type=’color’ 顏色選擇器。1&lt;input type=&quot;color&quot; value=&quot;#00ff00&quot;&gt; &lt;textarea&gt;建立一個可以輸入多行文字的輸入框。內容文字的換行是使用一般的文字換行符號 \\n。 屬性: name 欄位名稱。 rows 數字，設定欄高是幾行文字。 cols 數字，設定欄寬是幾行文字。 maxlength minlength placeholder 提示訊息。 disable 設定禁用。( 布林值 ) readonly 設定唯獨。( 布林值 ) required 設定必填。( 布林值 )12345&lt;textarea name=&quot;輸入框&quot; placeholder=&quot;說點什麼吧&quot; rows=&quot;8&quot; cols=&quot;16&quot; required&gt;&lt;/textarea&gt; 使用預設值則是將文字放在 &lt;textarea&gt; 標籤之間 12345&lt;textarea name=&quot;輸入框&quot; placeholder=&quot;說點什麼吧&quot; rows=&quot;8&quot; cols=&quot;16&quot; required&gt;12345&lt;/textarea&gt; 12345 &lt;select&gt; 、 &lt;option&gt; 、 &lt;optgroup&gt;&lt;select&gt; 建立下拉式選單的容器標籤。標籤上的屬性: name 欄位名稱。 disable 設定禁用。( 布林值 ) required 設定必填。( 布林值 ) multiple 設定選單中的選項可被多選。 size 指定一次顯示幾個選項。 在 &lt;select&gt; 裡面使用 &lt;option&gt; 標籤來建立個別選項。標籤上的屬性： value 設定的值。 selected 預先選取。( 布林值 ) label 用於說明選項。 disable 設定不可選。( 布林值 ) &lt;option&gt; 則是將選項分區顯示。 label 設定該分區的名稱。1234567891011121314&lt;select name=&quot;menu&quot;&gt;&lt;optgroup label=&quot;Coffee&quot;&gt; &lt;option&gt;Americano&lt;/option&gt; &lt;option&gt;Coffee Latte&lt;/option&gt; &lt;option&gt;Cappuccino&lt;/option&gt; &lt;option&gt;Caramel Macchiato&lt;/option&gt;&lt;/optgroup&gt;&lt;optgroup label=&quot;Dessert&quot;&gt; &lt;option&gt;Bagel&lt;/option&gt; &lt;option&gt;Pizza&lt;/option&gt; &lt;option&gt;Sandwich&lt;/option&gt; &lt;option&gt;Cake&lt;/option&gt;&lt;/optgroup&gt;&lt;/select&gt; Americano Coffee Latte Cappuccino Caramel Macchiato Bagel Pizza Sandwich Cake &lt;lable&gt;給表單的說明標題。將表單元件包在裡面，可增加表單的點擊範圍。使用 &lt;lable&gt; 的 for 屬性值，值設定為表單元件的id值，可增加表單的點擊範圍。 12&lt;label for=&quot;email&quot;&gt;Email address: &lt;/label&gt;&lt;input type=&quot;email&quot; name=&quot;user_email&quot; id=&quot;email&quot;&gt; Email : &lt;fieldest&gt; 、 &lt;legend&gt;&lt;fieldest&gt; 對表單做分組。&lt;legend&gt; 則是作為分組標題。屬性: name 聲明 fieldset 名稱。 disable 設定為禁用的狀態。 12345678910111213&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;基本資料&lt;/legend&gt; &lt;label for='user_name'&gt;姓名: &lt;/label&gt; &lt;input name=&quot;user_name&quot; id='user_name'&gt; &lt;label for='user_age'&gt;年齡: &lt;/label&gt; &lt;input type=&quot;number&quot; name=&quot;user_age&quot; id='user_age'&gt; &lt;/fieldset&gt; &lt;fieldset&gt; &lt;legend&gt;聯絡資訊&lt;/legend&gt; &lt;label for=&quot;user_email&quot;&gt;Email: &lt;/label&gt;&lt;input type=&quot;email&quot; name=&quot;user_email&quot; id=&quot;user_email&quot;&gt; &lt;label for=&quot;user_phone&quot;&gt;電話: &lt;/label&gt; &lt;input type=&quot;number&quot; name=&quot;phone&quot; id='user_phone'&gt; &lt;/fieldset&gt;&lt;/form&gt; 基本資料 姓名: 年齡: 聯絡資訊 Email: 電話: &lt;datalist&gt;和 &lt;input&gt; 欄位結合使用，建立一組資料清單，出現下拉式選單，提供給使用者可以直接選擇一個值。 建立的方式：1.在 &lt;input&gt; 標籤上設定一個 list屬性 = datalist 的 id2.在 &lt;datalist&gt; 標籤上設定一個 id3. 用 &lt;option&gt; 標籤在 &lt;datalist&gt; 裡面建立資料選項 123456789&lt;label&gt;今天來點什麼咖啡:&lt;input list=&quot;coffee&quot; name=&quot;coffee&quot;&gt;&lt;/label&gt;&lt;datalist id=&quot;coffee&quot;&gt; &lt;option value=&quot;Americano&quot;&gt; &lt;option value=&quot;Coffee Latte&quot;&gt; &lt;option value=&quot;Cappuccino&quot;&gt; &lt;option value=&quot;Caramel Macchiato&quot;&gt; &lt;option value=&quot;Macchiato&quot;&gt;&lt;/datalist&gt; 今天來點什麼咖啡: &lt;output&gt;用來顯示計算或操作表單的結果。屬性: for 值是關聯欄位的id，用空白分隔，指定此結果內容跟哪些欄位的值有關聯。 form 預設值是父層 form 元素的id。 name 表單欄位的名稱。12345678&lt;form oninput=&quot;x.value=parseInt(a.value)+parseInt(b.value)&quot;&gt; 0 &lt;input type=&quot;range&quot; id=&quot;a&quot; name=&quot;a&quot; value=&quot;50&quot;&gt; 100 + &lt;input type=&quot;number&quot; id=&quot;b&quot; name=&quot;b&quot; value=&quot;50&quot;&gt; = &lt;output name=&quot;x&quot; for=&quot;a b&quot;&gt;100&lt;/output&gt;&lt;/form&gt; 0 100 + = 100","link":"/2020/12/25/HTML/%E8%A1%A8%E5%96%AE%E6%A8%99%E7%B1%A4/"},{"title":"Javascript - AJAX","text":"AJAX 特性是無須重載整個頁面，便能對遠端server 發送請求。 AJAX利用 JavaScript 的 XMLHttpRequest 物件與遠端server 進行非同步的資料交換。特性是無須重載整個頁面，便能對遠端server 發送請求。 流程new XMLHttpRequest()建立 HTTP 請求。 .open(method, url[, async])open 方法指定請求。 method : 指定 HTTP method (GET, POST, PUT, DELETE…)。 url : 目標網址。 async : true(非同步，預設) / false (同步) 。 .send(null | formData)如果method是用POST，第一個參數是 Form data 格式。 .setRequestHeader(header, value)如果method是用POST，需要設定 HTTP header，要在open()後、send()前呼叫。 header : Content-Type value-HTML表單類型資料 : application/x-www-form-urlencoded value-JSON格式資料 : application/json value-XML格式資料 : text/xml 事件.onreadystatechange當 XMLHttpRequest 物件狀態改變時，透過 onreadystatechange 綁定的函數就會被執行。 屬性.readyState當前 XMLHttpRequest 物件狀態。值: 0 : 未連結(沒open) 1 : 未傳送(有open，沒send) 2 : 請求(有send) 3 : 回應資料中 4 : 回應完成 .statusText返回的回應狀態。值: 1xx : 參考的資訊。 2xx : 成功。 例如: 200 – ok 3xx : 重新導向。 4xx : 錯誤。 例如: 404 – not found 5xx : server錯誤。 .responseText請求返回的資料字串。 GET請求範例12345678910111213 var xhr = new XMLHttpRequest(); xhr.open('get', url); xhr.send(null); xhr.onreadystatechange = function () { if (httpRequest.readyState === 4) { if (httpRequest.status == 200) { console.log(xhr.responseText) } }} POST請求範例123456789101112131415 var xhr = new XMLHttpRequest(); xhr.open('post', url); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send('email = abcde123@gmail.com &amp; password = 1234'); xhr.onreadystatechange = function () { if (httpRequest.readyState === 4) { if (httpRequest.status == 200) { console.log(xhr.responseText) } }}","link":"/2020/12/01/JS/AJAX/"},{"title":"JavaScript – Array方法","text":"陣列的操作是JavaScript 裡很重要也很常用到的技巧。 push() 新增值12let Drink = ['water', 'coffee'];Drink.push('milk'); // [&quot;water&quot;, &quot;coffee&quot;, &quot;milk&quot;] array[array.length] 新增值12let Drink = ['water', 'coffee'];Drink[Drink.length]='milk'; // [&quot;water&quot;, &quot;coffee&quot;, &quot;milk&quot;] pop() 移除最後一個值，回傳移除的值12345let Drink = ['water', 'coffee','milk'];let newMenu = Drink.pop();console.log(Drink); // [&quot;water&quot;, &quot;coffee&quot;]console.log(newMenu); // milk shift() 移除第一個值，回傳移除的值12345let Drink = ['water', 'coffee','milk'];let newMenu = Drink.shift();console.log(Drink); // [&quot;coffee&quot;, &quot;milk&quot;]console.log(newMenu); // water concat() 合併陣列，回傳新陣列123let Drink1 = ['water', 'coffee'];let Drink2 = ['juice','milk'];let newMenu = Drink1.concat(Drink2); // [&quot;water&quot;, &quot;coffee&quot;, &quot;juice&quot;, &quot;milk&quot;] join() 將陣列依分隔符號合併成字串，預設是逗點，回傳字串。12let Drink = ['water', 'coffee',];Drink.join('+'); // water+coffee every() 檢查陣列是否全部都符合條件，回傳true / false。every(function(value, index){…}); value : 目前處理到的值。 index : 值的索引位置。123456let num = [2, 0, 21, 9, 28];let test = num.every(function (value) { return value &gt; 10;})console.log(test); // false some() 檢查陣列是否部分符合條件，回傳true / false。some(function(value, index){…}); value : 目前處理到的值。 index : 值的索引位置。123456let num = [2, 0, 21, 9, 28];let test = num.some(function (value) { return value &gt; 10;})console.log(test); // true filter() 篩選符合條件的值，回傳新陣列。filter(function(value, index){…}); value : 目前處理到的值。 index : 值的索引位置。123456let num = [2, 0, 21, 9, 28];let test = num.filter(function (value) { return value &gt; 10;})console.log(test); // [21, 28] forEach() 遍歷陣列，回傳undefined。forEach(function(value, index){…}); value : 目前處理到的值。 index : 值的索引位置。1234567let num = [2, 0, 21, 9, 28];let all = 0;let test = num.forEach(function (value) { all += value;})console.log(all); // 60 map() 遍歷陣列，回傳新陣列。map(function(value, index){…}); value : 目前處理到的值。 index : 值的索引位置。123456let num = [2, 0, 21, 9, 28];let test = num.map(function (value) { return value * 2;});console.log(test); // [4, 0, 42, 18, 56] indexOf() 找出值出現在陣列中的位置，回傳索引位置，沒找到則返回 -1。1234let num = [2, 0, 21, 9, 28];let test = num.indexOf(9)console.log(test); // 3 reverse() 倒轉陣列，回傳新陣列。1234let num = [2, 0, 21, 9, 28];let test = num.reverse()console.log(test); // [28, 9, 21, 0, 2] sort() 重新排序陣列，回傳新陣列。預設將值轉型成字串再比對每個字元的 Unicode code point 大小。sort(function(a, b){…}); a, b : 分別表示兩個比較的值，傳回一個數字。 回傳 : 數字小於 0 則 a 排序在 b 前面;大於 0 則 a 排序在 b 後面。1234let num = [2, 0, 21, 9, 28];let test = num.sort();console.log(test); // [0, 2, 21, 28, 9] 123456let num = [2, 0, 21, 9, 28];let test = num.sort(function (a, b) { return a - b;});console.log(test); // [0, 2, 9, 21, 28] unshift() 新增一個值到陣列最前面，回傳陣列長度。12345let num = [2, 0, 21, 9, 28];let test = num.unshift(6);console.log(test); // 6console.log(num); // [6, 2, 0, 21, 9, 28] reduce() 遍歷陣列，由左至右傳入函式運算，回傳累加值。reduce(function(allValue ,value, index){…}); allValue : 目前累加的值。 value : 目前處理到的值。 index : 值的索引位置。123456let num = [2, 0, 21, 9, 28];let test = num.reduce(function(a,b){ return a+ b;});console.log(test); // 60 reduceRight() 遍歷陣列，由右至左傳入函式運算，回傳累加值。reduceRight(function(allValue ,value, index){…}); allValue : 目前累加的值。 value : 目前處理到的值。 index : 值的索引位置。123456let num = [2, 0, 21, 9, 28];let test = num.reduceRight(function(a,b){ return a+ b;});console.log(test); // 60 splice() 刪除、插入值到陣列中，回傳新陣列。splice(索引位置, 刪除個數, 新值1, 新值2…) 12345let num = [2, 0, 21, 9, 28];let test = num.splice(3,2);console.log(test); // [9, 28]console.log(num); // [2, 0, 21] 12345let num = [2, 0, 21, 9, 28];let test = num.splice(3,2,12,30);console.log(test); // [9, 28]console.log(num); // [2, 0, 21, 12, 30]","link":"/2021/01/02/JS/Array-%E6%96%B9%E6%B3%95/"},{"title":"JavaScript - Async function 和 Await","text":"Async function 和 Await 兩者建構於 Promise 之上。 Sync (同步) / Async (非同步)Sync (同步) : 依序等待執行，一次執行完一件事，才能繼續往下執行。Async (非同步) : 可以一次處理不同需求，不須等待事件執行完畢才往下執行。 Async functionasync function 用來定義一個非同步函式 await運行在 async function 內，用來暫停非同步函式的運行，直到非同步進入 resolve (解決) 或 reject (出錯) 才會進入下一步。 例: 12345678910111213141516function promiseFn(num, s) { //Promise 函式 return new Promise(function (resolve) { // 回傳一個 promise setTimeout(resolve(`第 ${num} 輸出`), s); // 等待多少秒之後 resolve() });}promiseFn(1, 200).then(resolve =&gt; { // 使用 then 來接收 console.log(resolve); return promiseFn(2, 200); // 使用 return 來鏈接}).then(resolve =&gt; { console.log(resolve); return promiseFn(3, 200);}).then(resolve =&gt; { console.log(resolve);}) 也可以: 12345678910111213function promiseFn(num, s) { return new Promise(function (resolve) { // 回傳一個 promise setTimeout(resolve(`第 ${num} 輸出`), s); // 等待多少秒之後 resolve() });}async function delayFn() { // 回傳後才會往下依序執行 const data1 = await promiseFn(1, 200); const data2 = await promiseFn(2, 200); const data3 = await promiseFn(3, 200); console.log(data1, data2, data3);};delayFn();","link":"/2020/12/24/JS/Await/"},{"title":"JavaScript - Date.parse()","text":"Date.parse()將日期時間字串轉成毫秒數。 Date.parse(String)用來將日期時間字串轉成毫秒數。 String 格式: YYYY-MM-DD1Date.parse('2020-12-30'); YYYY-MM 1Date.parse('2020-12'); YYYY1Date.parse('2020'); YYYY-MM-DDTHH:MM:SS1Date.parse('2020-12-30T21:55:05'); MM/DD/YYYY1Date.parse('12/30/2020'); MMM DD YYYY1Date.parse('Dec 30 2020'); DD MMM YYYY1Date.parse('30 Dec 2020');","link":"/2020/12/30/JS/Date-parse/"},{"title":"JavaScript - Date物件","text":"Date物件用來做跟日期和時間相關的操作。 new Date();建立一個表示現在時間的 Date 物件。 1var today = new Date(); new Date(value);建立特定時間的 Date 物件，value 值單位是毫秒。 new Date(year,month[,date[,hours[,minutes[,seconds,[milliseconds]]]]]);建立特定時間的 Date 物件。 1var 我家仙人掌生日 = new Date(2019,10,11,11,11,11); month 表示月份的整數。由 0 開始（一月）到 11 （十二月）。hours 採 24 小時制。參數數值超過它的範圍，相鄰的參數值會被調整。 可以用 &gt;, &lt;, &lt;=, &gt;=, &lt;== 或 &gt;== 運算子來比較兩個 Date 物件的時間比較兩個日期是否相等，要將 Date 物件用 date.getTime() 轉換為數值型態才能比 取得日期和時間.getTime() 取得自 1970-01-01 00:00:00 UTC 累計的毫秒數.getFullYear() 取得年分。 12var today = new Date();var year = today.getFullYear(); .getMonth() 取得月分(0-11)。.getDate() 取得日期。.getDay() 取得星期(0-6)。 123var weekday = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'];var day = today.getDay();weekday[day]; .getHours().getMinutes().getSeconds().getMilliseconds() 設定日期和時間.setTime().setFullYear().setMonth().setDate().setHours().setMinutes().setSeconds().setMilliseconds()","link":"/2020/12/30/JS/Date%E7%89%A9%E4%BB%B6/"},{"title":"JavaScript – DOM 節點屬性","text":"使用 DOM 節點物件的屬性。 Node.nodeName取得節點名稱。 12345678&lt;div id=&quot;user&quot;&gt; &lt;span id=&quot;user1&quot;&gt;user123&lt;/span&gt;&lt;/div&gt;&lt;script&gt; let user = document.getElementById('user'); console.log(user.nodeName); // DIV&lt;/script&gt; Node.nodeValue用來取得 text, comment 和 CDATA 節點的內容。 12345678&lt;div id=&quot;user&quot;&gt; &lt;span id=&quot;user1&quot;&gt;user123&lt;/span&gt;&lt;/div&gt;&lt;script&gt; let user1 = document.getElementById('user1'); console.log(user1.firstChild.nodeValue); // user123&lt;/script&gt; Element.innerHTML修改/取得 一個元素節點中的 HTML 內容。 1234567891011&lt;div id=&quot;user&quot;&gt; &lt;span id=&quot;user1&quot;&gt;user123&lt;/span&gt;&lt;/div&gt;&lt;script&gt; let user = document.getElementById('user'); console.log(user.innerHTML); // &lt;span id=&quot;user1&quot;&gt;user123&lt;/span&gt; let user1 = document.getElementById('user1'); console.log(user1.innerHTML); // user123&lt;/script&gt; 123456789&lt;div id=&quot;user&quot;&gt; &lt;span id=&quot;user1&quot;&gt;user123&lt;/span&gt;&lt;/div&gt;&lt;script&gt; let user = document.getElementById('user'); user.innerHTML = `&lt;span id=&quot;user2&quot;&gt;user456&lt;/span&gt;`; console.log(user.innerHTML); // &lt;span id=&quot;user2&quot;&gt;user456&lt;/span&gt;&lt;/script&gt; Node.textContent和 innerHTML 用法類似，修改/取得 一個元素節點中的 HTML 內容。不過 textContent 會將 HTML 標籤去除，將 HTML 特殊符號自動轉成字元實體。 1234567891011&lt;div id=&quot;user&quot;&gt; &lt;span id=&quot;user1&quot;&gt;user123&lt;/span&gt;&lt;/div&gt;&lt;script&gt; let user = document.getElementById('user'); console.log(user.textContent); // user123 let user1 = document.getElementById('user1'); console.log(user1.textContent); // user123&lt;/script&gt; Element.outerHTML修改/取得 一個元素節點中的 HTML 內容，會返回包括節點本身的 HTML 內容。 12345678910&lt;div id=&quot;user&quot;&gt; &lt;span id=&quot;user1&quot;&gt;user123&lt;/span&gt;&lt;/div&gt;&lt;script&gt; let user = document.getElementById('user'); console.log(user.outerHTML); // &lt;div id=&quot;user&quot;&gt;&lt;span id=&quot;user1&quot;&gt;user123&lt;/span&gt;&lt;/div&gt;&lt;/script&gt; 123456789101112&lt;div id=&quot;user&quot;&gt; &lt;span id=&quot;user1&quot;&gt;user123&lt;/span&gt;&lt;/div&gt;&lt;script&gt; let user = document.getElementById('user'); let user1 = document.getElementById('user1'); user1.outerHTML = `&lt;span id=&quot;user2&quot;&gt;user456&lt;/span&gt;`; console.log(user.outerHTML); // &lt;div id=&quot;user&quot;&gt;&lt;span id=&quot;user2&quot;&gt;user456&lt;/span&gt;&lt;/div&gt;&lt;/script&gt;","link":"/2021/01/06/JS/DOM-%E7%AF%80%E9%BB%9E%E5%B1%AC%E6%80%A7/"},{"title":"Javascript - Fetch","text":"Fetch是基於Promise語法結構，用來執行請求、獲取Response(回應)物件。 Fetch基於 Promise 語法結構，用來執行請求、獲取 Response (回應)物件。 注意Fetch在只要伺服器有回應的情況，都會回傳fulfilled(已實現)的Promise物件狀態，其中也包含錯誤碼(404…)的情況。因此要以 response 的 status 的屬性值來判斷。可以使用 throw拋出例外，在 catch 區塊中引用。 12345fetch(url).then((response) =&gt; { if (response.status !== 200) throw new Error(response.status)}).catch((error) =&gt; { ...}) Request 屬性 url : 第一個參數，必填項目。 method : GET(預設)、POST、PUT、DELETE、HEAD。 headers : 要求相關的 Headers 物件 ( 預設 {} )。 Response 屬性 response.ok : 成功 ( 狀態碼 200-299 ) 為 true，失敗為 false。 response.status : 狀態代碼。 response.statusText : 狀態文字。 response.headers : 相關的 Headers 物件。 response.type : 此 response 的類型(例如： basic, cors)。 response.url : response 的 url。 Response 方法依照不同的資料類型使用對應的方法，才能真正取到資料物件。 json() text() blob() formData() arrayBuffer() GET用法123456789101112fetch('https://randomuser.me/api/', { method: 'GET' }) .then((response) =&gt; { if (response.status !== 200) throw new Error(response.status) console.log(response); return response.json(); }) .then((jsonData) =&gt; { console.log(jsonData) }) .catch((error) =&gt; { console.log('錯誤', error); }) POST用法1234567891011121314151617fetch(url, {method: 'POST', // headers 加入json格式 headers: { 'Content-Type': 'application/json' }, // body 將字串轉為json格式送出 body: JSON.stringify({ email: 'lovef1232e@hexschool.com', password: '12345678' })}).then((response) =&gt; { return response.json();}).then((jsonData) =&gt; { console.log(jsonData);}).catch((err) =&gt; { console.log('錯誤:', err);})","link":"/2020/12/01/JS/Fetch/"},{"title":"JavaScript – Math","text":"Math 是一個擁有數學常數及數學函數（非函式物件）屬性及方法的內建物件。 Math.abs()取得數字的絕對值。 1var num = Math.abs('-1'); // 1 Math.ceil();無條件進位。 1var num = Math.ceil('5.11'); // 6 Math.floor();無條件捨去。 1var num = Math.floor('5.11'); // 5 Math.round();四捨五入。 1var num = Math.round('5.6'); // 6 Math.random();返回一個 0 (包含) ~ 1 (不包含) 之間的隨機數。 1var num = Math.random(); // 0.5653752873923776 Math.max();取得傳入所有傳入參數的最大值。 1var num = Math.max(5,7,9,-3); // 9 Math.min();取得傳入所有傳入參數的最小值。 1var num = Math.min(5,7,9,-3); // -3","link":"/2020/12/25/JS/Math/"},{"title":"JavaScript – DOM 查找節點","text":"document 物件是 DOM tree 的根節點，表示整份 HTML 文件，要存取 HTML 都是從 document 物件開始。 document.getElementById(id)根據 id 取得一個 HTML 元素。 document.getElementsByTagName(tagName)根據 HTML 標籤 (tag) 取得所有這個標籤的集合，回傳一個陣列。 1var allP = document.getElementsByTagName('p'); document.getElementsByName(name)取得特定 name 屬性的 HTML 元素集合，回傳一個陣列。 1var users = document.getElementsByName('user'); document.getElementsByClassName(className)取得特定 className 的 HTML 元素集合，回傳一個陣列。 12// 取得同時有 person 和 tester 兩個 class name 的所有元素document.getElementsByClassName('person tester'); document.querySelector(selector)selector : 可以用 CSS 選擇器來尋找符合條件的第一個元素。 12345// 找出 className 是 user 的 HTML 元素document.querySelector('.user');name 屬性是 user 的 &lt;input&gt; 子元素 document.querySelector('input[name=user]'); document.querySelectorAll(selector)selector : 可以用 CSS 選擇器來尋找所有符合條件的元素，回傳一個陣列。 1document.querySelectorAll('p'); Node.children用來取得該元素下的所有子元素的集合(元素節點名稱，不包含文字節點)，回傳一個陣列。 1234567891011&lt;div id=&quot;user&quot;&gt; &lt;p&gt;user123&lt;/p&gt; &lt;p&gt;user456&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let user = document.getElementById('user'); var child = user.children; console.log(child); // [p, p]&lt;/script&gt; Node.childNodes用來取得該元素下的所有子元素集合，回傳一個陣列。 1234567891011&lt;div id=&quot;user&quot;&gt; &lt;p&gt;user123&lt;/p&gt; &lt;p&gt;user456&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let user = document.getElementById('user'); var child = user.childNodes; console.log(child); // [text, p, text, p, text]&lt;/script&gt; Node.firstChild取得該元素下的第一個子節點或返回 null 表示沒有任何子節點。 1234567891011&lt;div id=&quot;user&quot;&gt; &lt;p&gt;user123&lt;/p&gt; &lt;p&gt;user456&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let user = document.getElementById('user'); var child = user.children[0].firstChild; console.log(child); // user123&lt;/script&gt; Node.lastChild取得該元素下的最後個子節點或返回 null 表示沒有任何子節點。 Node.parentNode取得該元素的父元素節點。 1234567891011&lt;div id=&quot;user&quot;&gt; &lt;p&gt;user123&lt;/p&gt; &lt;p&gt;user456&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let user = document.getElementById('user'); var child = user.parentNode.nodeName; console.log(child); // BODY&lt;/script&gt; Node.previousSibling取得該元素前面的元素節點，回傳 null 表示已是第一個節點。 123456789101112131415&lt;div id=&quot;user&quot;&gt; &lt;p id=&quot;user1&quot;&gt;user123&lt;/p&gt; &lt;p&gt;user456&lt;span id=&quot;user2&quot;&gt;-789&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let user1 = document.getElementById('user1'); let user2 = document.getElementById('user2'); var child1 = user1.previousSibling; var child2 = user2.previousSibling console.log(child1); // #text console.log(child2); // user456&lt;/script&gt; Node.nextSibling取得該元素後面的元素節點，回傳 null 表示已是最後一個節點。","link":"/2021/01/03/JS/DOM-%E6%9F%A5%E6%89%BE%E7%AF%80%E9%BB%9E/"},{"title":"Javascript - Promise","text":"優化非同步操作的一個物件。 Promise 物件有三種狀態 : pending – 未確認(初始狀態) fulfilled – 事件實現 rejected – 事件失敗 而在建立 Promise 物件時，會有兩個參數 : resolve – 在Promise 物件的狀態變為 fulfilled，操作成功時調用。 reject – 在Promise 物件的狀態變為 rejected，操作失敗時調用。 建立Promise 物件1234567var promiseFn = new Promise(function (resolve, reject) { if (操作成功) { resolve(); } else { reject(); }}); Promise 物件原型方法Promise.prototype.then()then() 方法接受兩個分別要執行的參數 : 第一個參數是當 Promise 狀態變為fulfilled時調用。 第二個函數是當 Promise 狀態變為rejected時調用(選擇性)。 1234promiseFn.then( (resolve) =&gt;{...}, (reject) =&gt; {...}) Promise.prototype.catch()catch() 方法用來綁定當Promise 狀態變為rejected 狀態時，要執行的參數。 12345promiseFn.then( (resolve) =&gt;{...}).catch( (reject) =&gt; {...}) 使用 return 來串接後面的 then() 會接收前一個 then() 的 return value 當作參數。 1234567891011121314151617181920212223242526272829let text = document.getElementById('text');function promiseFn(num) { return new Promise(function (resolve, reject) { if (num &gt;= 10) { resolve(`成功投幣 ${num} 元`); } else { reject(`投幣 ${num} 元，金額不足`); } });}promiseFn(5).then( (res) =&gt; { console.log(res); return res }, (rej) =&gt; { console.log(rej); // 投幣 5 元，金額不足 return rej }).then( (res) =&gt; { text.textContent = res; }, (rej) =&gt; { text.textContent = rej; // 投幣 5 元，金額不足 }) Promise.all透過陣列形式傳入多個promise物件。所有 Promise 物件個別的返回值，會被組成一個陣列。若其中一個 Promise 物件狀態變為 rejected，則回傳reject 的值。 1234567891011121314151617Promise.all([promiseFn(15),promiseFn(20),promiseFn(35)]).then( (res) =&gt; { console.log(res); // [&quot;成功投幣 15 元&quot;, &quot;成功投幣 20 元&quot;, &quot;成功投幣 35 元&quot;] return res }, (rej) =&gt; { console.log(rej); return rej }).then( (res) =&gt; { text.textContent = res; // 成功投幣 15 元,成功投幣 20 元,成功投幣 35 元 }, (rej) =&gt; { text.textContent = rej; }) 1234567891011121314151617Promise.all([promiseFn(15),promiseFn(5),promiseFn(35)]).then( (res) =&gt; { console.log(res); return res }, (rej) =&gt; { console.log(rej); // 投幣 5 元，金額不足 return rej }).then( (res) =&gt; { text.textContent = res; }, (rej) =&gt; { text.textContent = rej; // 投幣 5 元，金額不足 }) Promise.racePromise.race() 一樣透過陣列形式傳入多個promise物件，不同的是取回第一個改變狀態promise物件的值。 1234567891011121314151617Promise.race([promiseFn(15),promiseFn(5),promiseFn(35)]).then( (res) =&gt; { console.log(res); return res }, (rej) =&gt; { console.log(rej); // 成功投幣 15 元 return rej }).then( (res) =&gt; { text.textContent = res; }, (rej) =&gt; { text.textContent = rej; // 成功投幣 15 元 })","link":"/2020/12/02/JS/Promise/"},{"title":"JavaScript – Object 資料複製","text":"關於淺層複製、深層複製。 淺層複製方法: Object.assign複製到第一層物件的屬性，若有第二層以上的資料會與舊物件一起共用同一塊記憶體。 12345678910111213141516171819var dog = { name : '舒跑', like : { food : '雞胸肉', game : '你丟我撿', bed : '主人的床' } }var newDog = Object.assign({}, dog);newDog.name = '可爾必思'; console.log(dog.name); // 舒跑console.log(newDog.name); // 可爾必思newDog.like.bed = '地板';console.log(dog.like.bed); // 地板console.log(newDog.like.bed); // 地板 淺層複製方法: …其餘運算子12345678910111213141516171819var dog = { name : '舒跑', like : { food : '雞胸肉', game : '你丟我撿', bed : '主人的床' }}var newDog = {...dog};newDog.name = '可爾必思';console.log(dog.name); // 舒跑console.log(newDog.name); // 可爾必思newDog.like.bed = '地板';console.log(dog.like.bed); // 地板console.log(newDog.like.bed); // 地板 深層複製方法: JSON複製建立全新的物件。JSON 方法限制:純資料的物件可行，有Function、Set、Map、undefined等型態會失效。 12345678910111213141516171819var dog = { name : '舒跑', like : { food : '雞胸肉', game : '你丟我撿', bed : '主人的床' }}var newDog = JSON.parse(JSON.stringify(dog));newDog.name = '可爾必思';console.log(dog.name); // 舒跑console.log(newDog.name); // 可爾必思newDog.like.bed = '地板';console.log(dog.like.bed); // 主人的床console.log(newDog.like.bed); // 地板 深層複製方法: $.extend12345678910var newDog = $.extend(true,{},dog);newDog.name = '可爾必思';console.log(dog.name); // 舒跑console.log(newDog.name); // 可爾必思newDog.like.bed = '地板';console.log(dog.like.bed); // 主人的床console.log(newDog.like.bed); // 地板","link":"/2020/12/12/JS/Object%E8%B3%87%E6%96%99%E8%A4%87%E8%A3%BD/"},{"title":"Javascript - 函式閉包","text":"函式閉包保存了內部函式的執行環境，可以持續存取。將變數指向外層函式，每一個變數都是獨立環境，可以反覆呼叫，重複持續存取內部函式環境。 建立在一個function函式中，return 另一個內部function函式。 1234567891011121314151617function wallet() { let money = 1000; return function (cash) { money = cash + money; return money; }}let personA = wallet();console.log(personA(100)); // 1100console.log(personA(100)); // 1200console.log(personA(300)); // 1500let personB = wallet();console.log(personB(200)); // 1200console.log(personB(500)); // 1700console.log(personB(-800)); // 900","link":"/2020/12/02/JS/%E5%87%BD%E5%BC%8F%E9%96%89%E5%8C%85/"},{"title":"JavaScript – call,apply,bind","text":"call, apply, bind 是函數物件中設定 this 關鍵字的內建方法。 fn.call(this-obj, value1…)call() 方法，可以用來改變 this 指向的物件，this-obj是 this 要指向的物件，value1…是要傳進函數的參數。 123456789101112var myName = 'Louisa';function tagName(a, b) { console.log(this.myName, a, b);};var family = { myName: 'Wei'};tagName(1, 2); // Louisa 1 2tagName.call(family, 1, 2); // Wei 1 2 fn.apply(this-obj[, value1…])apply() 跟 call() 的用途是一樣的，只是第二個參數是一個陣列。 1234567891011121314151617var myName = 'Louisa';function tagName(a, b) { console.log(this.myName, a, b);};var family = { myName: 'Wei'};tagName.apply(family, [5, 6, 7]); // Wei 5 6function re_tagName(a){ console.log(this.myName, a, arguments);}re_tagName.apply(family, [5, 6, 7]); // Wei 5 Arguments(3) [5, 6, 7] fn.bind(this-obj[, value1…])亦用來綁定 this 指向的方法，但call() 和 apply() 是直接執行function，bind() 是建立一個新的 function。 12345678910111213141516171819var myName = 'Louisa';function tagName(a, b) { console.log(this.myName, a, b);};var family = { myName: 'Wei'};function re_tagName(a){ console.log(this.myName, a, arguments);}var fn = tagName.bind(family, 8, 9);fn(); // Wei 8 9var fn2 = re_tagName.bind(family, 8, 9, 10);fn2(); // Wei 8 Arguments(3) [8, 9, 10]","link":"/2020/12/10/JS/call-apply-bind%E6%96%B9%E6%B3%95/"},{"title":"JavaScript – String(字串)","text":"紀錄JavaScript處理字串的一些方法。 String(x)將型別轉換成字串。 charAt(index)取得字串中特定位置的字。 123let sentence = 'Dink some water / tea / milk.';sentence.charAt(3); // k indexOf(str-value, index)找出某個字串在字串中的出現位置。返回找到的位置，找不到則返回 -1 。 12345let sentence = 'Dink some water / tea / milk.';sentence.indexOf('a'); // 11sentence.indexOf('a', 12); // 20 lastIndexOf(str-value, index)找出某個字串在字串中最後出現的位置。相對於indexOf() match(str-value)找出字串中匹配的內容，返回一個陣列。可搭配正規表達式 (Regex)使用。 12345let sentence = 'Dink some water / tea / milk.';let data = 'water / tea / milk.'console.log(sentence.match(data)); // [&quot;water / tea / milk.&quot;, index: 10, input: &quot;Dink some water / tea / milk.&quot;, groups: undefined] replace(old-str, new-str|function)將字串中的字取代為另外的字。 123let sentence = 'Dink some water / tea / milk.';sentence.replace('water', 'coffee'); // Dink some coffee / tea / milk. search(str-value)找出某個字串在字串中的出現位置，找不到則返回 -1 。可以用正規表達式 (Regex)當參數。 123let sentence = 'Dink some water / tea / milk.';sentence.search('a'); // 11 slice(begin-index, end-index)擷取兩個索引位置之間的字串，返回一個新字串。若begin-index大於字串長度，結果會返回空字串。 123let sentence = 'Dink some water / tea / milk.';sentence.slice(1, 7); // ink so split.(分隔符號 [,返回數量])根據指定的分隔字符，切割字串，返回一個字串陣列。 1234567let sentence = 'Dink some water / tea / milk.';sentence.split(' '); // [&quot;Dink&quot;, &quot;some&quot;, &quot;water&quot;, &quot;/&quot;, &quot;tea&quot;, &quot;/&quot;, &quot;milk.&quot;]sentence.split('k'); // [&quot;Din&quot;, &quot; some water / tea / mil&quot;, &quot;.&quot;]sentence.split(' ', 3); // [&quot;Dink&quot;, &quot;some&quot;, &quot;water&quot;] substr.(start-index [,擷取長度])切割擷取字串，返回一個新字串。擷取長度預設取到字串結尾。若start-index大於字串長度，結果會返回空字串。 12345let sentence = 'Dink some water / tea / milk.';sentence.substr(3); // k some water / tea / milk.sentence.substr(6, 3); // ome .toLowerCase()將字串中的英文字母都轉成小寫。 .toUpperCase()將字串中的英文字母都轉成大寫。 .trim()刪除字串兩側空格。","link":"/2020/12/12/JS/String-%E5%AD%97%E4%B8%B2/"},{"title":"JavaScript – this 指向","text":"影響 this 的指向是在於函式的呼叫方法。 函式this的指向: 全域物件window直接調用函式，函式的 this 會指向 window。 1234567var myName = 'Louisa';function callName() { var myName = &quot;John&quot;; console.log(this.myName);}callName(); // Louisa 函式this的指向: 物件本身作為物件方法來調用函式this，則會指向此物件。 123456789101112131415161718var myName = 'Louisa';function callName() { var myName = &quot;John&quot;; console.log(this.myName);}var family = { myName: 'Lee', callname: callName, Ming: { myName: ' Ming', callname: callName } } family.callname(); // Lee family.Ming.callname(); // Ming 間接執行函式，this的指向 : 全域物件window123456789101112131415161718var myName = 'Louisa';function callName() { var myName = &quot;John&quot;; console.log(this.myName);}var family = { myName: 'Lee', callname: callName, Ming: { myName: ' Ming', callname: callName } }var call_name = family.callname;call_name(); // Louisa 函式中的函式的this指向: 全域物件window1234567891011121314151617var myName = 'Louisa';function callName() { var myName = &quot;John&quot;; console.log(this.myName);}var family = { myName: 'Fido', rename: function () { setTimeout(function () { console.log(this.myName); }, 1000); }}family.rename(); // Louisa 函式中的函式的this指向 : 指回物件本身的方法123456789101112131415161718var myName = 'Louisa';function callName() { var myName = &quot;John&quot;; console.log(this.myName);}var family = { myName: 'Fido', rename: function () { var self = this; setTimeout(function () { console.log(self.myName); }, 1000); }}family.rename(); // Fido","link":"/2020/12/10/JS/%E6%8C%87%E5%90%91/"},{"title":"JavaScript – 物件原型、繼承","text":"JavaScript 的物件透過原型 (Prototype) 機制相互繼承功能。 物件建構式在建立Object時被呼叫，透過物件的建構函式定義屬性、方法，來建立物件實例。 宣告一個類別 (class)。 this 定義屬性。 prototype 定義方法。 new 添加物件實例。 1234567891011121314151617181920function Dog(name, color, weight) { this.name = name; this.color = color; this.weight = weight; }Dog.prototype.bark = function(){ console.log(this.name + '汪汪!'); }let Fido = new Dog('Fido','棕色',12);Fido.bark(); // Fido汪汪!console.log(Fido); // Dog {name: &quot;Fido&quot;, color: &quot;棕色&quot;, weight: 12}Fido.size = &quot;中型犬&quot;; // 添加新屬性delete Fido.size; // 刪除屬性Fido.game = function(){ // 添加新方法 console.log(this.name + '來玩你丟我撿'); } 原型繼承一個類別 (class)可繼承其他類別的屬性和方法，然後再延伸增加自己的屬性和方法。 .prototype.constructor 屬性，指向物件的建構函式。 .prototype._proto__ 屬性，指向物件繼承的原型。 Object.create(目標物件原型[，屬性]) 方法，使用目標物件作為新創建物件的原型來創建新物件。 Object.getPrototypeOf(obj) 方法，取得該物件的原型。 instanceof 運算子，判斷物件是否建立自指定的建構函式。 12345678910111213141516171819202122232425262728293031323334353637function Animal(family) { this.kingdom = '動物界'; this.family = family; }Animal.prototype.move = function() { console.log(this.name + '奔跑'); }function Dog(name, color, weight) { Animal.call(this, '犬科'); this.name = name; this.color = color; this.weight = weight; }Dog.prototype = Object.create(Animal.prototype);//建立多層繼承，透過Object.create複製了Animal.prototype全部的屬性Dog.prototype.constructor = Dog;//需要再將constructor重新指定回物件的建構函式本身。Dog.prototype.bark = function(){ console.log(this.name + '汪汪!'); }let Fido = new Dog('Fido','棕色',12);Fido.bark(); // Fido汪汪!Fido.move(); // Fido奔跑console.log(Fido); // Dog {kingdom: &quot;動物界&quot;, family: &quot;犬科&quot;, name: &quot;Fido&quot;, color: &quot;棕色&quot;, weight: 12}console.log(Object.getPrototypeOf(Fido)); // Animal {constructor: ƒ, bark: ƒ}console.log(Fido instanceof Animal); // true","link":"/2020/12/10/JS/%E7%89%A9%E4%BB%B6%E5%8E%9F%E5%9E%8B%E3%80%81%E7%B9%BC%E6%89%BF/"},{"title":"JavaScript – ... 其餘 &#x2F; 展開","text":"Javascript 在 ES6 裡引入了 … (三個點號)來表示展開或其餘運算子。 其餘參數表示函式所接受的參數數量不固定，而讓其餘參數合併成一個陣列。 1234function Fun(...arg) { console.log(arg.length); }Fun(); // 0Fun(5); // 1Fun(5, 6, 7); // 3 展開運算子用在執行函式時的參數上，可將一個陣列展開成多個獨立參數。 123456const vau = (...args) =&gt; { return args.reduce((a, b) =&gt; a + b, 0); }let arr = [2, 3, 4];vau(...arr); // 9vau(1, ...arr, 5); // 15 也可用來合併及展開陣列。 123let drink1 = ['milk', 'juice'];let drink2 = ['coffee', 'water'];let drink_menu = [...drink1, ...drink2]; //[&quot;milk&quot;, &quot;juice&quot;, &quot;coffee&quot;, &quot;water&quot;]","link":"/2020/12/10/JS/%E5%B1%95%E9%96%8B/"},{"title":"JavaScript – 物件屬性的調整","text":"針對物件的屬性調整。 Object.defineProperty(obj, prop, descriptor)調整物件屬性的特徵。 obj: 要定義屬性的目標物件。 prop: 要定義或修改的屬性的名稱。 descriptor: 參數，有value、writable、configurable、enumerable。 value修改屬性的值。 12345var list = {a: 1,b: 2,c: 3};Object.defineProperty(list,'a', {value :5});console.log(list); // {a: 5, b: 2, c: 3} writable屬性可否重新賦值。 12345678var list = {a: 1,b: 2,c: 3};list.a = 7 ;console.log(list); // {a: 7, b: 2, c: 3,}Object.defineProperty(list, 'a', {writable: false});list.a = 5 console.log(list); // {a: 7, b: 2, c: 3,} configurable屬性可否刪除。 12345678var list = {a: 1,b: 2,c: 3};Object.defineProperty(list, 'a', {configurable: false});delete list.a;console.log(list); // {a: 1,b: 2,c: 3}delete list.b;console.log(list); // {a: 1,c: 3} enumerable屬性可否被列舉(遍歷顯示)。 1234567891011var list = {a: 1,b: 2,c: 3};for (key in list){ console.log(key); // a, b, c}Object.defineProperty(list, 'a', {enumerable: false});for (key in list){ console.log(key); // b, c}","link":"/2020/12/10/JS/%E7%89%A9%E4%BB%B6%E5%B1%AC%E6%80%A7%E7%9A%84%E8%AA%BF%E6%95%B4/"},{"title":"關於固態硬碟的二三事 - TLC和SLC的差異是什麼? DRAM Cache又是什麼?","text":"SSD 固態硬碟是一種儲存硬碟類型，功能與傳統硬碟類似，但使用的技術不同。和 USB 隨身碟類似，SSD 使用快閃記憶體儲存資料，並以數位方式存取資料。 首先了解固態硬碟的內部構造： NAND 快閃記憶體：SSD儲存資料的部分，以非易失性，即斷電後仍能保存資料的記憶體塊。 DRAM Cache：少量的易失性記憶體（需要電源來維護資料）用於緩存未來訪問的資訊。 主控晶片：連接NAND快閃記憶體與電腦之間的主要電子元件。而常聽到的TLC和SLC顆粒就是指 NAND 快閃記憶體。 NAND快閃記憶體由多個存放以位元（bit）為單位的單元構成，這些位元通過電荷被打開或關閉，如何組織這些開關單元來儲存在 SSD 上的資料，也決定了 NAND 快閃記憶體的命名，比如單級單元（SLC）快閃記憶體在每個存儲單元中包含一個位元。 同樣的單元物理空間下，多級單元（MLC）能使容量翻倍，三級單元（TLC）更能使容量變為三倍，基於這種發展，為SSD趨向大容量開闢了道路。 在性能、體積的優勢基礎上，NAND 快閃記憶體目前發展的方向便是降低每比特存儲成本、提高存儲容量。因此就催生了後來的四級單元（QLC），即每個存儲單元有4個bits的格式。 單級單元（Single Level Cell，簡稱SLC）這類型的快閃記憶體在讀寫資料時具有最為精確，還具有最長的資料讀寫壽命的優點。SLC擦寫壽命約在9萬到10萬次之間。 多級單元（Multi Level Cell，簡稱MLC）多級單元俗稱 MLC，它的命名來源於它在 SLC 的 1bit/cell 的基礎上，變成了 2bit/cell。這樣做的一大優勢在於大大降低了大容量儲存快閃記憶體的成本。 三級單元（Triple Level Cell，簡稱TLC）TLC 快閃記憶體是快閃記憶體生產中最低廉的規格，其儲存達到了 3bit/cell，雖然高儲存密度實現了較廉價的大容量格式，但其讀寫的生命週期被極大地縮短，擦寫壽命只有短短的 500~1000次，同時讀寫速度較差。 四級單元（Quad-level cells，簡稱QLC）QLC 每個 SSD 顆粒可儲存 4bit 資料，跟 TLC 相比，QLC 的儲存密度提高了 33%。 DRAM Cache在SSD PCB上一個獨立的晶片，這顆DRAM晶片在SSD內負責的工作，就像一般記憶體在電腦運行過程中所負責的一樣，都是暫時存放部分數據，進而達到加速處理的目的。 因為有了這個暫存的功能，讓很多讀寫過程是可以直接使用暫存內的數據，速度上會比從頭開始快很多，但同時也和記憶體一樣，只要關機斷電就會自動清除數據。 另外，還有具備 SLC Cache 的固態硬碟，是在 TLC 或 QLC 的 NAND Flash IC 中，劃分出部分空間用來模擬 SLC 的寫入方式(每個 Cell 中只寫入 1bit 數據)，這樣就可以有效提升 SSD 在讀寫上的表現。","link":"/2023/04/03/%E6%9C%AA%E5%88%86%E9%A1%9E/%E9%97%9C%E6%96%BC%E5%9B%BA%E6%85%8B%E7%A1%AC%E7%A2%9F%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/"},{"title":"搞懂影片檔案格式與編解碼器","text":"檔案格式檔案格式就像是容器用來容納各種資訊，包含影片、音頻和元資料(檔案名稱、標籤、編解碼器資訊)，讓它可以做為單一檔案使用。 .mov（QuickTime）由 Apple 公司開發。與 MP4 檔一樣，MOV 視訊使用 MPEG-4 轉碼器進行編碼。 .mp4（MPEG-4 Part 14）被廣泛支援，並且與 H.264 編解碼器相容。適合用來製作高畫質影片，擁有相對較小的檔案大小。 擁有音訊視訊的MPEG-4檔案通常使用標準擴展名 .mp4 僅有音訊的MPEG-4檔案會使用 .m4a 視訊格式：高效率視訊編碼（H.265 / HEVC）、進階視訊編碼（H.264 / AVC） 音訊格式：進階音訊編碼（AAC） .avi（AVI）雖然仍然被廣泛運用，但是年歲已久，這個容器無法搭配許多現代編解碼器。 .wmv（WMV）限制眾多，它是舊版的微軟格式，只適用特定編解碼器。 .mkv（Matroska）和 .oog（Oog）這些是開放格式，，但是他們並未被廣泛支援。 AVCHD是索尼與松下電器聯合發表的高畫質光碟壓縮技術。AVCHD 標準基於 H.264 / MPEG-4 AVC 視訊編碼，支援480i、720p、1080i、1080p等格式，同時支援杜比數位5.1聲道或線性PCM 7.1聲道音訊壓縮。 編解碼器編解碼器是壓縮、解壓縮檔案格式內影片和音頻數據的軟體，讓剪輯素材更容易處理。 ProRes 422 和 ProRes 4444是蘋果公司開發的高品質的有損影片壓縮格式，可用於高達8K的後期製作。若使用 .mov 檔案，那麼 Apple ProRes 編解碼器會是個好選擇。ProRes能夠大量減少影片的檔案大小，同時保留許多畫質。 H.264/MPEG-4 AVC是線上分享高畫質影片的最佳選擇之一。雖然已經推出更新版本的H.265/HEVC編解碼器，但是H.264/AVC依然擁有廣泛支援。 H.265/HEVC被視為是 H.264/MPEG-4 AVC 標準的繼任者。不僅提昇影像品質，同時也能達到H.264/MPEG-4 AVC兩倍之壓縮率。最高解析度可達到8192×4320（8K解析度）。 社群媒體的最佳規格 .mp4最適合分享，因為它有廣泛支援，而且相對具備高畫質。 H.264是將影片上傳到Facebook、Instagram和Twitter的好選擇。它具備高畫質、廣泛支援，並且提供很棒的壓縮檔案大小。 如果有硬體設備，H.265非常適合超高畫質的直播影片。 YouTube接受許多不同的檔案類型。如果要追求畫質，最好能夠堅持使用ProRes編碼的 .mov或是H.264編碼的 .mp4檔案。 參考資料 shutterstock 維基百科","link":"/2022/08/03/%E6%9C%AA%E5%88%86%E9%A1%9E/%E6%90%9E%E6%87%82%E5%BD%B1%E7%89%87%E6%AA%94%E6%A1%88%E9%A1%9E%E5%9E%8B/"},{"title":"markdown 基本標籤使用","text":"markdown基本標籤的使用方法。 標題使用井字號為開頭。# 產生&lt;h1&gt;樣式，## 產生&lt;h2&gt;樣式。 粗體使用兩個 ** 前後包覆。例如 這句 範例 斜體使用一個 ** 前後包覆。例如 這句 範例 刪除線使用兩個波浪符前後包覆。例如 這句 範例 分隔線使用三個減號---。 插入連結使用 [連結名稱](連結網址)。例如 : Google 無序清單使用單個 - * + 都可以。 範例一 範例二 123456* 咖啡 * 拿鐵 * 美式* 奶茶 * 珍珠奶茶 * 鴛鴦奶茶 咖啡 拿鐵 美式 奶茶 珍珠奶茶 鴛鴦奶茶 有序清單使用數字. (1.) 即可。 範例一 範例二 插入圖片使用 ![圖片名稱](圖片路徑/連結網址)。 小區塊片段使用反引號`前後包覆。 大區塊片段前方使用四個空白。 程式碼區塊使用三個反引號```前後包覆。 引用標籤使用&gt;，此標籤是區塊元素。 引用範例 階層式區塊使用 &gt; ，依數量來製作階層。 例如: 1234&gt; 水果&gt;&gt; 番茄&gt;&gt;&gt; 大番茄&gt;&gt;&gt; 小番茄 水果 番茄 大番茄小番茄","link":"/2020/11/25/MARKDOWN/markdown%20%E5%9F%BA%E6%9C%AC%E6%A8%99%E7%B1%A4%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"Google Drive","slug":"Google-Drive","link":"/tags/Google-Drive/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"固態硬碟","slug":"固態硬碟","link":"/tags/%E5%9B%BA%E6%85%8B%E7%A1%AC%E7%A2%9F/"},{"name":"SSD","slug":"SSD","link":"/tags/SSD/"},{"name":"影片格式","slug":"影片格式","link":"/tags/%E5%BD%B1%E7%89%87%E6%A0%BC%E5%BC%8F/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"}],"categories":[{"name":"GOOGLE","slug":"GOOGLE","link":"/categories/GOOGLE/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"網頁","slug":"網頁","link":"/categories/%E7%B6%B2%E9%A0%81/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"未分類","slug":"未分類","link":"/categories/%E6%9C%AA%E5%88%86%E9%A1%9E/"},{"name":"MARKDOWN","slug":"MARKDOWN","link":"/categories/MARKDOWN/"}],"pages":[{"title":"categories","text":"","link":"/categories/index-1.html"},{"title":"","text":"如一棵樹、一顆石頭般的寫作你需要在這片土地經冬歷夏，等待時機。松樹的果實需要兩三個季節才能成熟，有些植物的根會在沙地裡休眠達七年之久，直到遇上一次降雨才又重新開始生長，而杉樹五十年才開一次花。——瑪麗．奧斯汀（Mary Austin） ，《無雨之地》","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"Tagcloud","text":"","link":"/tags/index.html"}]}